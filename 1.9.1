
#include <GL/freeglut.h>
#include <cmath>
#include <vector>
#include <string>
#include <map>
#include <ctime>
#include <cstdlib>
#include <GL/glu.h>

// --- Globalne varijable za kameru i interakciju ---
float cameraAngleX = 30.0f;
float cameraAngleY = 45.0f;
float cameraDistance = 20.0f;

int lastMouseX, lastMouseY;
bool leftMousePressed = false;

// --- L-System parametri ---
std::string axiom = "F"; // Početni aksiom
std::map<char, std::string> rules; // Pravila transformacije
std::string lsystemString; // Generisani L-System string
int lsystemDepth = 3; // Dubina generisanja L-Systema
float branchAngle = 30.0f; // Ugao grananja

// Dodati parametri za kontrolu veličine i debljine stabla
float segmentLengthMultiplier = 1.0f; // Osnovna dužina segmenta
float thicknessMultiplier = 1.0f;     // Osnovna debljina

// Struktura za 3D vektor
struct Vec3 {
    float x, y, z;
};

// Pozicije stabala u sceni
std::vector<Vec3> treePositions;

// --- Optimizacija: Cache za geometriju cilindra (trenutno nekorišćeno, ali dobro za VBO implementaciju) ---
struct CylinderCache {
    std::vector<float> vertices;
    std::vector<float> normals;
    bool isGenerated = false;
} cylinderCache;

// --- Funkcija za generisanje L-System stringa ---
std::string generateLSystem(const std::string& axiom, int depth) {
    std::string current = axiom;
    for (int i = 0; i < depth; ++i) {
        std::string next;
        next.reserve(current.length() * 7); // Rezervišemo memoriju za optimizaciju alokacije
        for (size_t j = 0; j < current.length(); ++j) {
            char c = current[j];
            if (rules.find(c) != rules.end())
                next += rules[c];
            else
                next += c;
        }
        current = next;
    }
    return current;
}

// --- Funkcija za regeneraciju L-Systema kada se promene parametri ---
void regenerateLSystem() {
    lsystemString = generateLSystem(axiom, lsystemDepth);
}

// --- Optimizovana funkcija za crtanje cilindra (grane) ---
void drawCylinderOptimized(float bottomRadius, float topRadius, float height) {
    const int segments = 6; // Smanjen broj segmenata za bolje performanse
    const float angleStep = 2.0f * 3.14159f / segments;

    // Crtamo samo stranice cilindra, ne i kapice (gornji/donji krug)
    glBegin(GL_TRIANGLE_STRIP);
    for (int i = 0; i <= segments; i++) {
        float angle = i * angleStep;
        float x1 = bottomRadius * cos(angle);
        float z1 = bottomRadius * sin(angle);
        float x2 = topRadius * cos(angle);
        float z2 = topRadius * sin(angle);

        // Normala za osvetljenje
        float nx = cos(angle);
        float nz = sin(angle);

        glNormal3f(nx, 0.0f, nz); // Normala po površini cilindra
        glVertex3f(x1, 0.0f, z1);
        glVertex3f(x2, height, z2);
    }
    glEnd();
}

// --- Funkcija za crtanje lista kao sfere ---
void drawLeafSphere(float radius) {
    glColor3f(0.2f, 0.6f, 0.1f); // Zelena boja za list

    glPushMatrix();
    // Možete dodati manje translacije ako želite da se sfere ne preklapaju previše sa granom
    // Na primer, malo iznad tačke grane: glTranslatef(0.0f, radius * 0.5f, 0.0f);

    // GLUT ima ugrađenu funkciju za crtanje sfere
    // Poslednja dva parametra su slices i stacks (segmenti po horizontali i vertikali)
    // Smanjite ih ako vam treba bolja performansa za veliki broj listova
    glutSolidSphere(radius, 6, 6); // Sfera sa 6 segmenata za brže renderovanje
    glPopMatrix();

    // Vratiti boju na braon za grane, da ne bi i grane bile zelene!
    glColor3f(0.55f, 0.35f, 0.2f);
}


// --- Glavna funkcija za crtanje stabla na osnovu L-System stringa ---
void drawTree(const std::string& lsys) {
    glPushMatrix(); // Sačuvaj trenutnu matricu transformacije
    float segmentLength = 1.2f * segmentLengthMultiplier; // Početna dužina segmenta
    float thickness = 0.25f * thicknessMultiplier; // Početna debljina grane
    int depth = 0; // Trenutna dubina grananja

    // Prekalkulisane konstante za efikasnost
    const float thicknessReduction = 0.65f; // Smanjenje debljine po segmentu
    const float lengthReduction = 0.8f;     // Smanjenje dužine po segmentu
    const float branchThicknessReduction = 0.8f; // Smanjenje debljine pri grananju
    const float branchLengthReduction = 0.9f;    // Smanjenje dužine pri grananju

    for (size_t i = 0; i < lsys.length(); ++i) {
        char c = lsys[i];
        switch (c) {
            case 'F': // Crtaj segment (granu)
                // Preskoči crtanje vrlo malih segmenata radi performansi
                if (thickness > 0.005f && segmentLength > 0.01f) {
                    drawCylinderOptimized(thickness, thickness * 0.7f, segmentLength);
                    glTranslatef(0.0f, segmentLength, 0.0f); // Pomeri se na kraj segmenta
                }
                thickness *= thicknessReduction; // Smanji debljinu za sledeći segment
                segmentLength *= lengthReduction; // Smanji dužinu za sledeći segment
                break;
            case 'L': // Crtaj list kao sferu
                // Crtaj list samo ako je grana dovoljno debela/duga
                if (thickness > 0.01f && segmentLength > 0.05f) {
                    drawLeafSphere(thickness * 1.5f); // Veličina lista sfere proporcionalna debljini grane
                }
                break;
            case '+': glRotatef(branchAngle, 0.0f, 0.0f, 1.0f); break; // Okreni se levo (Z-osa)
            case '-': glRotatef(-branchAngle, 0.0f, 0.0f, 1.0f); break; // Okreni se desno (Z-osa)
            case '&': glRotatef(branchAngle, 1.0f, 0.0f, 0.0f); break; // Savij se dole (X-osa)
            case '^': glRotatef(-branchAngle, 1.0f, 0.0f, 0.0f); break; // Savij se gore (X-osa)
            case '\\': glRotatef(branchAngle, 0.0f, 1.0f, 0.0f); break; // Okreni se desno (Y-osa)
            case '/': glRotatef(-branchAngle, 0.0f, 1.0f, 0.0f); break; // Okreni se levo (Y-osa)
            case '|': glRotatef(180.0f, 0.0f, 0.0f, 1.0f); break; // Okreni se za 180 stepeni
            case '[': // Početak grane (sačuvaj stanje)
                glPushMatrix();
                depth++; // Povećaj dubinu
                thickness *= branchThicknessReduction; // Smanji debljinu za novu granu
                segmentLength *= branchLengthReduction; // Smanji dužinu za novu granu
                break;
            case ']': // Kraj grane (vrati prethodno stanje)
                glPopMatrix();
                depth--; // Smanji dubinu
                // Rekalkulacija thickness i segmentLength nakon povratka iz grane
                // Ovo osigurava da se debljina i dužina vrate na vrednost koju su imali pre grananja
                thickness = 0.25f * thicknessMultiplier;
                segmentLength = 1.2f * segmentLengthMultiplier;
                float depthFactorThickness = 1.0f;
                float depthFactorLength = 1.0f;
                for(int d = 0; d < depth; d++) {
                    depthFactorThickness *= branchThicknessReduction * thicknessReduction; // Prilagođeno da prati redukciju u granama
                    depthFactorLength *= branchLengthReduction * lengthReduction; // Prilagođeno da prati redukciju u granama
                }
                thickness *= depthFactorThickness;
                segmentLength *= depthFactorLength;
                break;
        }
    }
    glPopMatrix(); // Vrati originalnu matricu transformacije
}

// --- Inicijalizacija OpenGL parametara i podataka ---
void init() {
    glClearColor(0.5f, 0.8f, 1.0f, 1.0f); // Svetlo plava pozadina (nebo)
    glEnable(GL_DEPTH_TEST); // Uključi test dubine za ispravno renderovanje 3D objekata
    glEnable(GL_LIGHTING);   // Uključi osvetljenje
    glEnable(GL_LIGHT0);     // Uključi svetlo broj 0
    glEnable(GL_COLOR_MATERIAL); // Omogući da glColor postavlja materijalne osobine
    glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE); // Boja objekta utiče na ambijentalnu i difuznu komponentu

    // Postavke svetla
    GLfloat lightPos[] = {5.0f, 10.0f, 5.0f, 1.0f}; // Pozicija svetla
    GLfloat lightDiffuse[] = {1.0f, 1.0f, 1.0f, 1.0f}; // Difuzna boja svetla (bela)
    GLfloat lightAmbient[] = {0.4f, 0.4f, 0.4f, 1.0f}; // Ambijentalna boja svetla (svetlo siva)
    glLightfv(GL_LIGHT0, GL_POSITION, lightPos);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, lightDiffuse);
    glLightfv(GL_LIGHT0, GL_AMBIENT, lightAmbient);

    // Definisanje L-System pravila
    // Dodat je 'L' za crtanje lista na kraju svake 'F' grane
    rules['F'] = "F[+F][-F][&F][^F]L"; // F -> grana, [ ] -> grananje, + - & ^ \ / | -> rotacije, L -> list

    regenerateLSystem(); // Generiši početni L-System string

    // Inicijalizacija generatora slučajnih brojeva
    srand((unsigned int)time(0));
    // Generisanje pozicija za stabla (manji broj za bolje performanse)
    for (int i = 0; i < 15; ++i) { // Smanjeno na 15 stabala
        float x = (rand() % 200 - 100) / 10.0f; // Slučajna X pozicija (-10 do 10)
        float z = (rand() % 200 - 100) / 10.0f; // Slučajna Z pozicija (-10 do 10)
        treePositions.push_back({x, 0.0f, z}); // Dodaj poziciju
    }
}

// --- Funkcija za iscrtavanje scene ---
void display() {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // Obriši bafer boja i dubine
    glLoadIdentity(); // Resetuj matricu modela i pogleda

    // Pozicija kamere iz sfernih koordinata
    float camX = cameraDistance * sinf(cameraAngleY * 3.14f / 180.0f) * cosf(cameraAngleX * 3.14f / 180.0f);
    float camY = cameraDistance * sinf(cameraAngleX * 3.14f / 180.0f);
    float camZ = cameraDistance * cosf(cameraAngleY * 3.14f / 180.0f) * cosf(cameraAngleX * 3.14f / 180.0f);

    gluLookAt(camX, camY, camZ, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0); // Postavi kameru

    // Crtanje terena (ravna zelena površina)
    glColor3f(0.3f, 0.8f, 0.3f); // Boja terena (zelena)
    glBegin(GL_QUADS);
        glNormal3f(0.0f, 1.0f, 0.0f); // Normala za teren (gore)
        glVertex3f(-15.0f, 0.0f, -15.0f);
        glVertex3f( 15.0f, 0.0f, -15.0f);
        glVertex3f( 15.0f, 0.0f,  15.0f);
        glVertex3f(-15.0f, 0.0f,  15.0f);
    glEnd();

    // Crtanje stabala
    glColor3f(0.55f, 0.35f, 0.2f); // Boja stabala (braon) - ovo je početna boja koja se menja u drawLeafSphere()
    for (size_t i = 0; i < treePositions.size(); ++i) {
        glPushMatrix(); // Sačuvaj trenutnu matricu za svako stablo
        glTranslatef(treePositions[i].x, treePositions[i].y, treePositions[i].z); // Pomeri na poziciju stabla
        drawTree(lsystemString); // Nactaj stablo
        glPopMatrix(); // Vrati originalnu matricu
    }

    glutSwapBuffers(); // Zameni bafer, prikaži nacrtanu scenu
}

// --- Funkcija za promenu veličine prozora ---
void reshape(int w, int h) {
    if (h == 0) h = 1; // Izbegni deljenje sa nulom
    float ratio = (float)w / (float)h;

    glMatrixMode(GL_PROJECTION); // Postavi matricu projekcije
    glLoadIdentity();            // Resetuj je
    gluPerspective(45, ratio, 1, 1000); // Postavi perspektivnu projekciju
    glViewport(0, 0, w, h);      // Postavi viewport
    glMatrixMode(GL_MODELVIEW);  // Vrati se na matricu modela i pogleda
}

// --- Funkcija za obradu pokreta miša ---
void motion(int x, int y) {
    if (leftMousePressed) {
        cameraAngleY += (x - lastMouseX); // Rotacija po Y osi
        cameraAngleX += (y - lastMouseY); // Rotacija po X osi
        // Ograniči rotaciju po X osi da se izbegne okretanje kamere naglavačke
        if (cameraAngleX > 89.0f) cameraAngleX = 89.0f;
        if (cameraAngleX < -89.0f) cameraAngleX = -89.0f;
    }

    lastMouseX = x; // Ažuriraj poslednje pozicije miša
    lastMouseY = y;

    glutPostRedisplay(); // Zahtevaj ponovno iscrtavanje scene
}

// --- Funkcija za obradu klika miša ---
void mouse(int button, int state, int x, int y) {
    if (button == GLUT_LEFT_BUTTON) {
        leftMousePressed = (state == GLUT_DOWN); // Proveri da li je levi taster pritisnut/pušten
        lastMouseX = x;
        lastMouseY = y;
    }
}

// --- Funkcija za obradu izbora iz menija ---
void menu(int option) {
    // Kontrola ugla grananja
    if (option == 1) branchAngle = 15.0f;
    else if (option == 2) branchAngle = 30.0f;
    else if (option == 3) branchAngle = 45.0f;
    else if (option == 4) branchAngle = 60.0f;

    // Kontrola dubine L-Systema
    else if (option == 10) lsystemDepth = 2;
    else if (option == 11) lsystemDepth = 3;
    else if (option == 12) lsystemDepth = 4;
    else if (option == 13) lsystemDepth = 5;

    // Kontrola dužine segmenata
    else if (option == 20) segmentLengthMultiplier = 0.5f;
    else if (option == 21) segmentLengthMultiplier = 1.0f;
    else if (option == 22) segmentLengthMultiplier = 1.5f;
    else if (option == 23) segmentLengthMultiplier = 2.0f;
    else if (option == 24) segmentLengthMultiplier = 3.0f;

    // Kontrola debljine
    else if (option == 30) thicknessMultiplier = 0.5f;
    else if (option == 31) thicknessMultiplier = 1.0f;
    else if (option == 32) thicknessMultiplier = 1.5f;
    else if (option == 33) thicknessMultiplier = 2.0f;
    else if (option == 34) thicknessMultiplier = 3.0f;

    regenerateLSystem(); // Regeneriši L-System string sa novim parametrima
    glutPostRedisplay(); // Zahtevaj ponovno iscrtavanje
}

// --- Funkcija za obradu skrola miša (zumiranje) ---
void mouseWheel(int button, int dir, int x, int y) {
    if (dir > 0) // Skrol gore
        cameraDistance -= 1.0f;
    else // Skrol dole
        cameraDistance += 1.0f;

    // Ograniči udaljenost kamere
    if (cameraDistance < 2.0f) cameraDistance = 2.0f;
    if (cameraDistance > 100.0f) cameraDistance = 100.0f;

    glutPostRedisplay(); // Zahtevaj ponovno iscrtavanje
}

// --- Glavna funkcija programa ---
int main(int argc, char** argv) {
    glutInit(&argc, argv); // Inicijalizacija FreeGLUT-a
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH); // Dvostruki bafer, RGB boje, bafer dubine
    glutInitWindowSize(800, 600); // Početna veličina prozora
    glutCreateWindow("Projekat Petnica"); // Naslov prozora

    init(); // Pozovi funkciju za inicijalizaciju

    // Kreiranje i podešavanje menija desnog klika
    glutCreateMenu(menu);
    glutAddMenuEntry("=== Ugao grananja ===", -1); // Separator/naslov
    glutAddMenuEntry("15 stepeni", 1);
    glutAddMenuEntry("30 stepeni", 2);
    glutAddMenuEntry("45 stepeni", 3);
    glutAddMenuEntry("60 stepeni", 4);

    glutAddMenuEntry("=== Dubina ===", -1);
    glutAddMenuEntry("Dubina 2", 10);
    glutAddMenuEntry("Dubina 3", 11);
    glutAddMenuEntry("Dubina 4", 12);
    glutAddMenuEntry("Dubina 5", 13);

    glutAddMenuEntry("=== Duzina segmenata ===", -1);
    glutAddMenuEntry("Kratko (0.5x)", 20);
    glutAddMenuEntry("Normalno (1.0x)", 21);
    glutAddMenuEntry("Dugo (1.5x)", 22);
    glutAddMenuEntry("Vrlo dugo (2.0x)", 23);
    glutAddMenuEntry("Ogromno (3.0x)", 24);

    glutAddMenuEntry("=== Debljina ===", -1);
    glutAddMenuEntry("Tanko (0.5x)", 30);
    glutAddMenuEntry("Normalno (1.0x)", 31);
    glutAddMenuEntry("Debelo (1.5x)", 32);
    glutAddMenuEntry("Vrlo debelo (2.0x)", 33);
    glutAddMenuEntry("Ogromno (3.0x)", 34);

    glutAttachMenu(GLUT_RIGHT_BUTTON); // Poveži meni sa desnim klikom miša

    // Registracija callback funkcija
    glutDisplayFunc(display);       // Funkcija za crtanje
    glutReshapeFunc(reshape);       // Funkcija za promenu veličine prozora
    glutMouseFunc(mouse);           // Funkcija za klik miša
    glutMotionFunc(motion);         // Funkcija za pokret miša
    glutMouseWheelFunc(mouseWheel); // Funkcija za skrol miša

    glutMainLoop(); // Pokreni glavnu petlju FreeGLUT-a
    return 0;
}
